# 尽量提交小的CL

*翻译自：https://github.com/google/eng-practices/blob/master/review/developer/small-cls.md*

## 为什么要编写小的CL？

短小简单的CL，有如下好处：
+ **让review更快完成**。对于reviewer来说，花五分钟来review一个小的CL比耗费半个小时去review一个大的CL更容易。
+ **review进行的更彻底**。对于大的改动，评论者和作者往往会因为大量的详细的注释来回改变而感到沮丧，有时重要的信息点甚至会遗漏或丢失。
+ **降低引入bug的可能性**。由于您所做的更改更少，所以您和您的reviewer更容易有效地推断CL的影响，并查看是否引入了错误。
+ **如果被拒绝，浪费的工作就会更少**。如果您编写了一个巨大的CL，然后您的reviewer说总体方向是错误的，那么您就浪费了很多工作。
+ **容易合并**。处理大型CL需要很长时间，所以在合并时将会有很多冲突，而且必须经常合并。
+ **更容易做出好的设计**。完善小变更的设计和代码运行状况要比完善大变更的所有细节容易得多。
+ **工作不容易因为review而阻塞**。发送整体更改的自包含部分，可以让您在当前CL处于检查状态时继续编码。
+ **容易回滚**。较大的CL更有可能会在初始CL提交和回滚CL之间涉及到更多文件，从而使回滚变得复杂，甚至一些中间的CL可能也需要回滚。

请注意，reviewer有权以您的更改太大为唯一理由直接拒绝您的更改。通常，他们会感谢你的贡献，但要求你以某种方式把它变成一系列较小的变化。在您已经编写了一个变更之后，可能需要花费大量的工作来分割它，或者需要花费大量的时间来争论为什么reviewer应该接受您的大变更。首先就编写小的CL就比较轻松了。

## 怎样才算是小CL？

通常一个CL的合适大小是一个自包含的修改，具有如下特征：
+ 该CL通过一些小的改动**只解决一件事情**。这通常只是一个功能的一部分，而不是一个完整的功能。一般来说，太小的CL或太大的CL都不好，不过两害相权取其轻的话，编写太小的CL要比太大的CL要好，当然，你最好是和reviewer一起找到可接受的大小。
+ 除了未来的开发之外，reviewer需要了解的内容，都应该在当前CL中，当前CL的描述中，或者他之前review过的内容中。
+ 当前CL签入后不影响系统的正常运行。
+ CL不能小到难以理解的程度。例如您添加了一个新的API，应该在相同的CL中包含该API的用法，以便审阅人员能够更好地理解如何使用该API。这还可以防止签入不会被使用到的api。

如何判断一个CL过大，并没有影响的规定。通常来说，100行的CL可能是合理的，超过1000行的CL可能就有点大了，这取决于reviewer如何判断。CL涉及到的改动文件数也可能会导致CL过大，一个200行的CL只涉及到一个文件的改动可能是合适的，但是如果涉及到50个文件就太大了。

请注意，你从开始编写代码的时候起就与代码密切相关，但是reviewer通常没有这样的上下文。对你来说，一个大小尚可的CL对于review来说可能就较大了。当你对于CL的大小心存疑虑的时候，就去编写比你预想更小的CL，这通常都不会差，因为基本没人会抱怨CL过小。

## 什么情况下大的CL是可以接受的？

有一些情况，大的CL也是可以的，例如：
+ 删除整个文件可以当作“改动一行”来对待，因为这种改动不会需要太多review时间。
+ 有时候，一个您完全信任的自动重构工具会生成一个很大的CL，审查人员的工作就是检查并确认他们是否确实需要更改。这些CLs可能很大，会与上面的一些警告(如合并和测试)相悖，但却是可以接受的。

## 按文件拆分CL

另一种分割CL的方法是对文件进行分组，这些文件需要不同的审阅人员，但都是自包含的更改。

例如: 发送一个CL用于修改pb协议，另一个CL用于修改使用该pb协议的代码。您必须在代码CL之前提交pb协议CL，但是它们可以同时被审查。如果您把这两个CL分别提交给两组reviewer，您可能需要编写的另一个CL通知给这两组reviewer，以便他们了解您这两个CL所做改动的上下文。

又例如：您发送一个CL进行代码更改，发送另一个CL进行使用该代码的配置或实验，这是很适合拆分的。因为一般来说将配置/实验文件推送到生产环境比代码变更要快，如果必要时，也更容易回滚。

## 独立重构

通常最好在一个独立的CL中进行重构，而不是进行特性更改或bug修复时同时做重构变更。例如，移动和重命名一个类应该与修复该类中的错误属于不同的CL。当每个CL独立时，reviewer更容易理解它们所引入的更改。

不过，可以在特性更改或bug修复CL中包含一些类似于修复局部变量名之类的小重构改动。由developer和reviewer来判断重构动作是否过大，以至于如果包含到当前CL中会导致review变得困难。

## 将相关的测试代码放到相同的CL中

不要将测试代码分割成单独的CL。即使它增加了代码行数，也应该把验证代码修改的测试应该放在同一个CL中。

不过，和独立重构类似，独立的测试修改应该纳入到独立的CL中去。例如：
+ 为了验证已存在/已提交代码的新测试；
+ 重构测试代码（例如，引入一些帮助函数）；
+ 引入更大的测试框架代码（例如，集成测试）。

## 不要破坏构建

如果您有几个相互依赖的CLs，那么您需要找到一种方法来确保在提交每个CL之后整个系统都能继续工作。否则，您可能会在CL提交之间中断所有其他开发人员的构建几分钟(如果在以后的CL提交中出现意外的问题，则可能需要更长的时间)。

## 没办法把CL做到足够小

有时您会遇到这样的情况，您的CL似乎必须很大。这种情况其实很少。实践编写小型CL的作者几乎总能找到方法，将功能分解为一系列小的CL。

在编写大型CL之前，考虑下如果首先提交一些重构的CL，是否可以为更干净的实现铺平道路。与您的团队交流，看看其他人有没有办法在小的CL中来实现该功能。

如果还是不行（应该是极少的情况了），请先取得reviewer的同意，让他们对于即将要进行大型CL的review做好准备。这种情况下，可能会需要花费更多的review时间，对于可能引入的bug要提高警惕，需要编写更多的测试。

下一篇：[如何处理reviewer的评论](handling-comments.md)
